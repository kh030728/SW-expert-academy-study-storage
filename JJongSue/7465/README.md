# 7465 창용 마을 무리의 개수



[링크](https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWngfZVa9XwDFAQU&categoryId=AWngfZVa9XwDFAQU&categoryType=CODE)

### 문제 설명


창용 마을에는 N명의 사람이 살고 있다.

사람은 편의상 1번부터 N번 사람까지 번호가 붙어져 있다고 가정한다.

두 사람은 서로를 알고 있는 관계일 수 있고, 아닐 수 있다.

두 사람이 서로 아는 관계이거나 몇 사람을 거쳐서 알 수 있는 관계라면,

이러한 사람들을 모두 다 묶어서 하나의 무리라고 한다.

창용 마을에 몇 개의 무리가 존재하는지 계산하는 프로그램을 작성하라.




### 제약 사항

- 시간 : 10개 테스트케이스를 합쳐서 C의 경우 1초 / C++의 경우 1초 / Java의 경우 2초 / Python의 경우 2초 
- 메모리 : 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내 




-------------------------------------------

### 입출력 예

[입력]

첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 각각 창용 마을에 사는 사람의 수와 서로를 알고 있는 사람의 관계 수를 나타내는

두 정수 N, M(1 ≤ N ≤ 100, 0 ≤ M ≤ N(N-1)/2) 이 공백 하나로 구분되어 주어진다.

이후 M개의 줄에 걸쳐서 서로를 알고 있는 두 사람의 번호가 주어진다.

같은 관계는 반복해서 주어지지 않는다.
 
[출력]
각 테스트 케이스마다 ‘#x’(x는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고,

무리의 개수를 출력한다. 







### 입출력 예 설명

..



-------------------------------------------

### 풀이

- is_visted는 방문여부를 확인하는 bool vector
- network는 1과 2과 연결되어 있을경우 network[0][1]과 network[1][0]이 true인 2중 bool vector이다
- dfs 함수는 is_visted와 network 그리고 int N을 입력받는 함수이다.

dfs는 N번째의 마을과 연결된 network를 차례로 방문하는데, is_visted로 방문 여부를 확인하고, network끼리 연결되어 있을 경우, 방문하여 연결되어 있지 않을때 까지 반복하는 함수이다.
main문에서 for문을 통해 1~N까지 dfs를 반복하고 반복한 휫수만큼 answer++를 수행하면 무리의 개수를 찾을 수 있다.



