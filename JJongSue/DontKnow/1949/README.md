# 1949 등산로 조성

[링크](https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5QSEhaA5sDFAUq&categoryId=AV5QSEhaA5sDFAUq&categoryType=CODE)
- 시간 :  50개 테스트케이스를 합쳐서 C의 경우 3초 / C++의 경우 3초 / Java의 경우 3초 / Python의 경우 15초 
- 메모리 : 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내 

### 문제 설명
등산로를 조성하려고 한다.

등산로를 만들기 위한 부지는 N * N 크기를 가지고 있으며, 이곳에 최대한 긴 등산로를 만들 계획이다.

등산로 부지는 아래 [Fig. 1]과 같이 숫자가 표시된 지도로 주어지며, 각 숫자는 지형의 높이를 나타낸다.
![1](https://user-images.githubusercontent.com/34182908/55465284-bd433880-5637-11e9-8704-2ca56846fb23.JPG)
등산로를 만드는 규칙은 다음과 같다.

	① 등산로는 가장 높은 봉우리에서 시작해야 한다.

	② 등산로는 산으로 올라갈 수 있도록 반드시 높은 지형에서 낮은 지형으로 가로 또는 세로 방향으로 연결이 되어야 한다.
       즉, 높이가 같은 곳 혹은 낮은 지형이나, 대각선 방향의 연결은 불가능하다.

   	③ 긴 등산로를 만들기 위해 딱 한 곳을 정해서 최대 K 깊이만큼 지형을 깎는 공사를 할 수 있다.

N * N 크기의 지도가 주어지고, 최대 공사 가능 깊이 K가 주어진다.

이때 만들 수 있는 가장 긴 등산로를 찾아 그 길이를 출력하는 프로그램을 작성하라.

### 예시
위 [Fig. 1]과 같이 N = 5인 지도가 주어진 경우를 살펴보자.

가장 높은 봉우리는 높이가 9로 표시된 세 군데이다.

이 세 곳에서 출발하는 가장 긴 등산로 중 하나는 아래 [Fig. 2]와 같고, 이 때 길이는 5가 된다.
![2](https://user-images.githubusercontent.com/34182908/55465466-25921a00-5638-11e9-8b58-9bbc9ef1e44f.JPG)
만약 최대 공사 가능 깊이 K = 1로 주어질 경우,

아래 [Fig. 3]과 같이 빨간색 부분의 높이를 9에서 8로 깎으면 길이가 6인 등산로를 만들 수 있다.

![3](https://user-images.githubusercontent.com/34182908/55465488-317ddc00-5638-11e9-85c9-ff19cd429915.JPG)
이 예에서 만들 수 있는 가장 긴 등산로는 위와 같으며, 출력할 정답은 6이 된다.

### 제약 사항
- 시간 제한 : 최대 50개 테스트 케이스를 모두 통과하는 데 C/C++/Java 모두 3초

- 지도의 한 변의 길이 N은 3 이상 8 이하의 정수이다. (3 ≤ N ≤ 8)

- 최대 공사 가능 깊이 K는 1 이상 5 이하의 정수이다. (1 ≤ K ≤ 5)

- 지도에 나타나는 지형의 높이는 1 이상 20 이하의 정수이다.

- 지도에서 가장 높은 봉우리는 최대 5개이다.

- 지형은 정수 단위로만 깎을 수 있다.

- 필요한 경우 지형을 깎아 높이를 1보다 작게 만드는 것도 가능하다.

-------------------------------------------
### 입출력 예

[입력]

입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T가 주어지고, 그 다음 줄부터 T개의 테스트 케이스가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 지도의 한 변의 길이 N, 최대 공사 가능 깊이 K가 차례로 주어진다.

그 다음 N개의 줄에는 N * N 크기의 지도 정보가 주어진다.


[출력]

테스트 케이스 개수만큼 T개의 줄에 각각의 테스트 케이스에 대한 답을 출력한다.

각 줄은 "#t"로 시작하고 공백을 하나 둔 다음 정답을 출력한다. (t는 1부터 시작하는 테스트 케이스의 번호이다)

출력해야 할 정답은 만들 수 있는 가장 긴 등산로의 길이이다. 

![4](https://user-images.githubusercontent.com/34182908/55465644-86b9ed80-5638-11e9-8d9c-915c4be0239c.JPG)



### 입출력 예 설명
..

-------------------------------------------
### 풀이
- 이중 벡터 mount에 산의 정보를 넣고, height_max에 산의 최고 높이를 저장
- 그 후 최고 높이 일때만, x+1, y+1, x-1, y-1의 경우에 dfs를 수행하고 높이 1과 함께 max를 출력
- dfs는 x,y가 범위를 초과하거나 이미 방문했거나, 이전 높이보다 크고, 땅을 팠을때도 이전 높이보다 클경우 0을 리턴
- 높이가 작을 경우 4개의 dfs 수행, level+1 중 max 리턴
- 땅을 팠을 때 이전 높이보다 작을 경우 높이에 이전높이-1 인 값을 dfs 4개에 넣고 level+1 max를 리턴

